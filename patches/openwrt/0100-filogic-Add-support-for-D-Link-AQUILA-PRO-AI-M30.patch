From 7a3cb8e1c66b98b49d9b3ca2a07692274eded05b Mon Sep 17 00:00:00 2001
From: Roland Reinl <reinlroland+github@gmail.com>
Date: Sun, 7 Apr 2024 22:00:28 +0200
Subject: [PATCH] filogic: Add support for D-Link AQUILA PRO AI M30

---
 include/image-commands.mk                     |  37 +++
 .../uboot-envtools/files/mediatek_filogic     |   3 +
 package/kernel/leds-gca230718/Makefile        |  34 ++
 package/kernel/leds-gca230718/src/Makefile    |   1 +
 .../leds-gca230718/src/leds-gca230718.c       | 227 +++++++++++++
 .../mt7981b-dlink-aquila-pro-ai-m30-a1.dts    | 313 ++++++++++++++++++
 .../filogic/base-files/etc/board.d/02_network |   3 +
 .../etc/hotplug.d/ieee80211/11_fix_wifi_mac   |   4 +
 .../filogic/base-files/etc/init.d/bootcount   |   7 +
 target/linux/mediatek/image/filogic.mk        |  15 +
 10 files changed, 644 insertions(+)
 create mode 100644 package/kernel/leds-gca230718/Makefile
 create mode 100644 package/kernel/leds-gca230718/src/Makefile
 create mode 100644 package/kernel/leds-gca230718/src/leds-gca230718.c
 create mode 100644 target/linux/mediatek/dts/mt7981b-dlink-aquila-pro-ai-m30-a1.dts

diff --git a/include/image-commands.mk b/include/image-commands.mk
index 6666eddf8f..12cbbb2c2c 100644
--- a/include/image-commands.mk
+++ b/include/image-commands.mk
@@ -226,6 +226,43 @@ define Build/copy-file
 	cat "$(1)" > "$@"
 endef
 
+# Create a header for a D-Link AI series recovery image and add it at the beginning of the image
+# Currently supported: AQUILA M30, EAGLE M32 and R32
+# Arguments:
+# 1: Start string of the header
+# 2: Firmware version
+# 3: Block start address
+# 4: Block length
+# 5: Device FMID
+define Build/dlink-ai-recovery-header
+	$(eval header_start=$(word 1,$(1)))
+	$(eval firmware_version=$(word 2,$(1)))
+	$(eval block_start=$(word 3,$(1)))
+	$(eval block_length=$(word 4,$(1)))
+	$(eval device_fmid=$(word 5,$(1)))
+# create $@.header without the checksum
+	echo -en "$(header_start)\x00\x00" > "$@.header"
+# Calculate checksum over data area ($@) and append it to the header.
+# The checksum is the 2byte-sum over the whole data area.
+# Every overflow during the checksum calculation must increment the current checksum value by 1.
+	od -v -w2 -tu2 -An --endian little "$@" | awk '{ s+=$$1; } END { s%=65535; printf "%c%c",s%256,s/256; }' >> "$@.header"
+	echo -en "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00" >> "$@.header"
+	echo -en "$(firmware_version)" >> "$@.header"
+# Only one block supported: Erase start/length is identical to data start/length
+	echo -en "$(block_start)$(block_length)$(block_start)$(block_length)" >> "$@.header"
+# Only zeros
+	echo -en "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" >> "$@.header"
+# Last 16 bytes, but without checksum
+	echo -en "\x42\x48\x02\x00\x00\x00\x08\x00\x00\x00\x00\x00" >> "$@.header"
+	echo -en "$(device_fmid)" >> "$@.header"
+# Calculate and append checksum: The checksum must be set so that the 2byte-sum of the whole header is 0.
+# Every overflow during the checksum calculation must increment the current checksum value by 1.
+	od -v -w2 -tu2 -An --endian little "$@.header" | awk '{s+=65535-$$1;}END{s%=65535;printf "%c%c",s%256,s/256;}' >> "$@.header"
+	cat "$@.header" "$@" > "$@.new"
+	mv "$@.new" "$@"
+	rm "$@.header"
+endef
+
 define Build/dlink-sge-image
 	$(STAGING_DIR_HOST)/bin/dlink-sge-image $(1) $@ $@.enc
 	mv $@.enc $@
diff --git a/package/boot/uboot-envtools/files/mediatek_filogic b/package/boot/uboot-envtools/files/mediatek_filogic
index 65872b60f5..f8466109cc 100644
--- a/package/boot/uboot-envtools/files/mediatek_filogic
+++ b/package/boot/uboot-envtools/files/mediatek_filogic
@@ -57,6 +57,9 @@ cmcc,rax3000m)
 		;;
 	esac
 	;;
+dlink,aquila-pro-ai-m30-a1)
+	ubootenv_add_uci_config "/dev/mtd1" "0x0" "0x40000" "0x40000"
+	;;
 glinet,gl-mt3000)
 	ubootenv_add_uci_config "/dev/mtd1" "0x0" "0x80000" "0x20000"
 	;;
diff --git a/package/kernel/leds-gca230718/Makefile b/package/kernel/leds-gca230718/Makefile
new file mode 100644
index 0000000000..a1ae3bc319
--- /dev/null
+++ b/package/kernel/leds-gca230718/Makefile
@@ -0,0 +1,34 @@
+#
+# Copyright (C) 2008-2010 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+include $(TOPDIR)/rules.mk
+include $(INCLUDE_DIR)/kernel.mk
+
+PKG_NAME:=leds-gca230718
+PKG_RELEASE:=1
+PKG_LICENSE:=GPL-2.0
+
+include $(INCLUDE_DIR)/package.mk
+
+define KernelPackage/leds-gca230718
+  SUBMENU:=LED modules
+  TITLE:=GCA230718 LED support (e.g. for D-Link M30)
+  FILES:= \
+	$(PKG_BUILD_DIR)/leds-gca230718.ko
+  AUTOLOAD:=$(call AutoProbe,leds-gca230718,1)
+  DEPENDS:=@TARGET_mediatek_filogic
+endef
+
+define KernelPackage/leds-gca230718/description
+  GCA230718 LED support (e.g. for D-Link M30) using I2C.
+endef
+
+define Build/Compile
+	$(KERNEL_MAKE) M="$(PKG_BUILD_DIR)" modules
+endef
+
+$(eval $(call KernelPackage,leds-gca230718))
diff --git a/package/kernel/leds-gca230718/src/Makefile b/package/kernel/leds-gca230718/src/Makefile
new file mode 100644
index 0000000000..eaa4eef219
--- /dev/null
+++ b/package/kernel/leds-gca230718/src/Makefile
@@ -0,0 +1 @@
+obj-m := leds-gca230718.o
diff --git a/package/kernel/leds-gca230718/src/leds-gca230718.c b/package/kernel/leds-gca230718/src/leds-gca230718.c
new file mode 100644
index 0000000000..d759453cd9
--- /dev/null
+++ b/package/kernel/leds-gca230718/src/leds-gca230718.c
@@ -0,0 +1,227 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * GCA230718 LED support (e.g. for D-Link M30) using I2C
+ *
+ * Copyright 2022 Roland Reinl <reinlroland+github@gmail.com>
+ *
+ * This driver can control RGBW LEDs which are connected to a GCA230718.
+ */
+
+#include <linux/delay.h>
+#include <linux/led-class-multicolor.h>
+#include <linux/leds.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/property.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <linux/version.h>
+
+#define GCA230718_MAX_LEDS                                      (4u)
+
+#define GCA230718_OPMODE_DISABLED                               (0x00u)
+#define GCA230718_OPMODE_NO_TOGGLE                              (0x01u)
+#define GCA230718_OPMODE_TOGGLE_RAMP_CONTROL_DISABLED           (0x02u)
+#define GCA230718_OPMODE_TOGGLE_RAMP_CONTROL_ENSABLED           (0x03u)
+
+#define GCA230718_1ST_SEQUENCE_BYTE_1                           (0x02u)
+#define GCA230718_2ND_SEQUENCE_BYTE_1                           (0x01u)
+#define GCA230718_3RD_SEQUENCE_BYTE_1                           (0x03u)
+
+struct gca230718_led
+{
+	enum led_brightness brightness;
+	struct i2c_client *client;
+	struct led_classdev ledClassDev;
+};
+
+struct gca230718_private
+{
+	struct mutex lock;
+	struct gca230718_led leds[GCA230718_MAX_LEDS];
+};
+
+static void gca230718_init_private_led_data(struct gca230718_private* data)
+{
+	u8 ledIndex;
+	for (ledIndex = 0; ledIndex < GCA230718_MAX_LEDS; ledIndex++)
+	{
+		data->leds[ledIndex].client = NULL;
+	}
+}
+
+static void gca230718_send_sequence(struct i2c_client *client, u8 byte0, struct gca230718_private* gca230718_privateData)
+{
+	int status = 0;
+	u8 ledIndex;
+	const u8 resetCommand[2] = { 0x81, 0xE4 };
+	const u8 resetCommandRegister = 0x00;
+
+	u8 controlCommand[13];
+	const u8 controlCommandRegister = 0x03;
+
+	controlCommand[0] = 0x0C; /* Unknown */
+	controlCommand[1] = byte0;
+	controlCommand[2] = GCA230718_OPMODE_NO_TOGGLE;
+	/* Byte 3-6 are set below to the brighness value of the individual LEDs */
+	controlCommand[7] = 0x01; /* Frequency, doesn't care as long as GCA230718_OPMODE_NO_TOGGLE is used above */
+	/* Byte 8-11 are set below to the brighness value of the individual LEDs */
+	controlCommand[12] = 0x87;
+
+	for (ledIndex = 0; ledIndex < GCA230718_MAX_LEDS; ledIndex++)
+	{
+		controlCommand[3 + ledIndex] = gca230718_privateData->leds[ledIndex].brightness;
+		controlCommand[8 + ledIndex] = gca230718_privateData->leds[ledIndex].brightness;
+	}
+
+	mutex_lock(&(gca230718_privateData->lock));
+
+	if ((status = i2c_smbus_write_i2c_block_data(client, resetCommandRegister, sizeof(resetCommand), resetCommand)) != 0)
+	{
+		pr_info("Error %i during call of i2c_smbus_write_i2c_block_data for reset command\n", status);
+	}
+	else if ((status = i2c_smbus_write_i2c_block_data(client, controlCommandRegister, sizeof(controlCommand), controlCommand)) != 0)
+	{
+		pr_info("Error %i during call of i2c_smbus_write_i2c_block_data for control command\n", status);
+	}
+
+	mutex_unlock(&(gca230718_privateData->lock));
+}
+
+static int gca230718_set_brightness(struct led_classdev *led_cdev, enum led_brightness value)
+{
+	struct gca230718_led* led;
+	struct i2c_client* client;
+
+	led = container_of(led_cdev, struct gca230718_led, ledClassDev);
+	client = led->client;
+
+	if (client != NULL)
+	{
+		struct gca230718_private* gca230718_privateData;
+
+		led->brightness = value;
+		gca230718_privateData = i2c_get_clientdata(client);
+
+		gca230718_send_sequence(client, GCA230718_2ND_SEQUENCE_BYTE_1, gca230718_privateData);
+	}
+
+	return 0;
+}
+
+static int gca230718_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	int status = 0;
+	struct gca230718_private* gca230718_privateData;
+
+	pr_info("Enter gca230718_probe for device address %u\n", client->addr);
+	gca230718_privateData = devm_kzalloc(&(client->dev), sizeof(struct gca230718_private), GFP_KERNEL);
+
+	if (gca230718_privateData == NULL)
+	{
+		pr_info("Error during allocating memory for private data\n");
+		status = -ENOMEM;
+	}
+	else
+	{
+		struct device_node* ledNode;
+		mutex_init(&gca230718_privateData->lock);
+		gca230718_init_private_led_data(gca230718_privateData);
+		i2c_set_clientdata(client, gca230718_privateData);
+
+		for_each_child_of_node(client->dev.of_node, ledNode)
+		{
+			u32 regValue = 0;
+			if (of_property_read_u32(ledNode, "reg", &regValue) != 0)
+			{
+				pr_info("Missing entry \"reg\" in node %s\n", ledNode->name); 
+			}
+			else if (regValue >= GCA230718_MAX_LEDS)
+			{
+				pr_info("Invalid entry \"reg\" in node %s (%u)\n", ledNode->name, regValue);
+			}
+			else
+			{
+				struct led_classdev* ledClassDev = &(gca230718_privateData->leds[regValue].ledClassDev);
+				struct led_init_data init_data = {};
+
+				gca230718_privateData->leds[regValue].client = client;
+				init_data.fwnode = of_fwnode_handle(ledNode);
+
+				pr_info("Creating LED for node %s: reg=%u\n", ledNode->name, regValue); 
+
+				ledClassDev->name = of_get_property(ledNode, "label", NULL);
+				if (ledClassDev->name == NULL)
+				{
+					ledClassDev->name = ledNode->name;
+				}
+
+				ledClassDev->brightness = LED_OFF;
+				ledClassDev->max_brightness = LED_FULL;
+				ledClassDev->brightness_set_blocking = gca230718_set_brightness;
+	
+				if (devm_led_classdev_register_ext(&(client->dev), ledClassDev, &init_data) != 0)
+				{
+					pr_info("Error during call of devm_led_classdev_register_ext");
+				}
+			}
+		}
+	}
+
+	if (status == 0)
+	{
+		/* 
+		Send full initialization sequence.
+		Afterwards only GCA230718_2ND_SEQUENCE_BYTE_1 must be send to upddate the brightness values.
+		*/
+		gca230718_send_sequence(client, GCA230718_1ST_SEQUENCE_BYTE_1, gca230718_privateData);
+		gca230718_send_sequence(client, GCA230718_2ND_SEQUENCE_BYTE_1, gca230718_privateData);
+		gca230718_send_sequence(client, GCA230718_3RD_SEQUENCE_BYTE_1, gca230718_privateData);
+	}
+
+	return status;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,18,0)
+static void gca230718_remove(struct i2c_client *client)
+#else
+static int gca230718_remove(struct i2c_client *client)
+#endif
+{
+	struct gca230718_private* gca230718_privateData;
+	gca230718_privateData = i2c_get_clientdata(client);
+	mutex_destroy(&gca230718_privateData->lock);
+	gca230718_init_private_led_data(gca230718_privateData);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,18,0)
+	return 0;
+#endif
+}
+
+static const struct i2c_device_id gca230718_i2c_ids[] = {
+	{ "gca230718", 0 },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, gca230718_i2c_ids);
+
+static const struct of_device_id gca230718_dt_ids[] = {
+	{ .compatible = "unknown,gca230718" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, gca230718_dt_ids);
+
+static struct i2c_driver gca230718_driver = {
+	.probe		= gca230718_probe,
+	.remove		= gca230718_remove,
+	.id_table	= gca230718_i2c_ids,
+	.driver = {
+		.name		= KBUILD_MODNAME,
+		.of_match_table	= gca230718_dt_ids,
+	},
+};
+
+module_i2c_driver(gca230718_driver);
+
+MODULE_AUTHOR("Roland Reinl <reinlroland+github@gmail.com>");
+MODULE_DESCRIPTION("GCA230718 LED support (e.g. for D-Link M30) using I2C");
+MODULE_LICENSE("GPL");
diff --git a/target/linux/mediatek/dts/mt7981b-dlink-aquila-pro-ai-m30-a1.dts b/target/linux/mediatek/dts/mt7981b-dlink-aquila-pro-ai-m30-a1.dts
new file mode 100644
index 0000000000..4e145630bb
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7981b-dlink-aquila-pro-ai-m30-a1.dts
@@ -0,0 +1,313 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+
+/dts-v1/;
+
+#include "mt7981.dtsi"
+
+/ {
+	model = "D-Link AQUILA PRO AI M30 A1";
+	compatible = "dlink,aquila-pro-ai-m30-a1", "mediatek,mt7981";
+
+	aliases {
+		label-mac-device = &gmac0;
+		led-boot = &led_status_white;
+		led-failsafe = &led_status_red;
+		led-running = &led_status_white;
+		led-upgrade = &led_status_blue;
+		serial0 = &uart0;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		button-reset {
+			label = "reset";
+			linux,code = <KEY_RESTART>;
+			gpios = <&pio 0 GPIO_ACTIVE_LOW>;
+		};
+
+		button-wps {
+			label = "wps";
+			linux,code = <KEY_WPS_BUTTON>;
+			gpios = <&pio 1 GPIO_ACTIVE_LOW>;
+		};
+
+		button-leds-on-off {
+			label = "leds-on-off";
+			linux,code = <KEY_LIGHTS_TOGGLE>;
+			gpios = <&pio 4 GPIO_ACTIVE_LOW>;
+		};
+	};
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&watchdog {
+	status = "okay";
+};
+
+&eth {
+	pinctrl-names = "default";
+	pinctrl-0 = <&mdio_pins>;
+
+	status = "okay";
+
+	gmac0: mac@0 {
+		compatible = "mediatek,eth-mac";
+		reg = <0>;
+		phy-mode = "2500base-x";
+
+		nvmem-cells = <&macaddr_odm 1>;
+		nvmem-cell-names = "mac-address";
+
+		fixed-link {
+			speed = <2500>;
+			full-duplex;
+			pause;
+		};
+	};
+
+	gmac1: mac@1 {
+		compatible = "mediatek,eth-mac";
+		reg = <1>;
+		phy-mode = "gmii";
+		phy-handle = <&int_gbe_phy>;
+		label = "internet";
+
+		nvmem-cells = <&macaddr_odm 0>;
+		nvmem-cell-names = "mac-address";
+	};
+};
+
+&mdio_bus {
+	switch: switch@1f {
+		compatible = "mediatek,mt7531";
+		reg = <31>;
+		reset-gpios = <&pio 39 GPIO_ACTIVE_HIGH>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				label = "lan1";
+			};
+
+			port@1 {
+				reg = <1>;
+				label = "lan2";
+			};
+
+			port@2 {
+				reg = <2>;
+				label = "lan3";
+			};
+
+			port@3 {
+				reg = <3>;
+				label = "lan4";
+			};
+
+			port@6 {
+				reg = <6>;
+				label = "cpu";
+				ethernet = <&gmac0>;
+				phy-mode = "2500base-x";
+
+				fixed-link {
+					speed = <2500>;
+					full-duplex;
+					pause;
+				};
+			};
+		};
+	};
+};
+
+&spi0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi0_flash_pins>;
+	status = "okay";
+
+	spi_nand@0 {
+		compatible = "spi-nand";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		reg = <0>;
+
+		spi-max-frequency = <52000000>;
+		spi-tx-bus-width = <4>;
+		spi-rx-bus-width = <4>;
+
+		mediatek,nmbm;
+		mediatek,bmt-max-ratio = <1>;
+		mediatek,bmt-max-reserved-blocks = <64>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "BL2";
+				reg = <0x00 0x100000>;
+				read-only;
+			};
+
+			partition@100000 {
+				label = "u-boot-env";
+				reg = <0x100000 0x80000>;
+			};
+
+			partition@180000 {
+				label = "Factory";
+				reg = <0x180000 0x200000>;
+				read-only;
+
+				nvmem-layout {
+					compatible = "fixed-layout";
+					#address-cells = <1>;
+					#size-cells = <1>;
+
+					eeprom_factory_0: eeprom@0 {
+						reg = <0x0 0x1000>;
+					};
+				};
+			};
+
+			partition@380000 {
+				label = "FIP";
+				reg = <0x380000 0x200000>;
+				read-only;
+			};
+
+			partition@580000 {
+				label = "ubi";
+				reg = <0x580000 0x3200000>;
+			};
+
+			partition@3780000 {
+				label = "ubi1";
+				reg = <0x3780000 0x3200000>;
+				read-only;
+			};
+
+			partition@6980000 {
+				label = "Odm";
+				reg = <0x6980000 0x40000>;
+				read-only;
+
+				nvmem-layout {
+					compatible = "fixed-layout";
+					#address-cells = <1>;
+					#size-cells = <1>;
+
+					macaddr_odm: macaddr@81 {
+						compatible = "mac-base";
+						reg = <0x81 0x6>;
+						#nvmem-cell-cells = <1>;
+					};
+				};
+				
+			};
+
+			partition@69c0000 {
+				label = "Config1";
+				reg = <0x69c0000 0x80000>;
+				read-only;
+			};
+
+			partition@6a40000 {
+				label = "Config2";
+				reg = <0x6a40000 0x80000>;
+				read-only;
+			};
+
+			partition@6ac0000 {
+				label = "Storage";
+				reg = <0x6ac0000 0xA00000>;
+				read-only;
+			};
+		};
+	};
+};
+
+&pio {
+	spi0_flash_pins: spi0-pins {
+		mux {
+			function = "spi";
+			groups = "spi0", "spi0_wp_hold";
+		};
+
+		conf-pu {
+			pins = "SPI0_CS", "SPI0_HOLD", "SPI0_WP";
+			drive-strength = <MTK_DRIVE_8mA>;
+			bias-pull-down = <MTK_PUPD_SET_R1R0_00>;
+		};
+
+		conf-pd {
+			pins = "SPI0_CLK", "SPI0_MOSI", "SPI0_MISO";
+			drive-strength = <MTK_DRIVE_8mA>;
+			bias-pull-down = <MTK_PUPD_SET_R1R0_00>;
+		};
+	};
+
+	i2c_pins_g0: i2c-pins-g0 {
+		mux {
+			function = "i2c";
+			groups = "i2c0_1";
+		};
+	};
+};
+
+&wifi {
+	status = "okay";
+
+	nvmem-cells = <&macaddr_odm 2>;
+	nvmem-cell-names = "mac-address";
+
+	nvmem-cells = <&eeprom_factory_0>;
+	nvmem-cell-names = "eeprom";
+};
+
+&i2c0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c_pins_g0>;
+
+	gca230718@40 {
+		compatible = "unknown,gca230718";
+		reg = <0x40>;
+
+		led_status_red: led@0 {
+			color = <LED_COLOR_ID_RED>;
+			function = LED_FUNCTION_STATUS;
+			reg = <0>;
+		};
+
+		led@1 {
+			color = <LED_COLOR_ID_GREEN>;
+			function = LED_FUNCTION_STATUS;
+			reg = <1>;
+		};
+
+		led_status_blue: led@2 {
+			color = <LED_COLOR_ID_BLUE>;
+			function = LED_FUNCTION_STATUS;
+			reg = <2>;
+		};
+
+		led_status_white: led@3 {
+			color = <LED_COLOR_ID_WHITE>;
+			function = LED_FUNCTION_STATUS;
+			reg = <3>;
+		};
+	};
+};
diff --git a/target/linux/mediatek/filogic/base-files/etc/board.d/02_network b/target/linux/mediatek/filogic/base-files/etc/board.d/02_network
index 566a5ca82f..99ce3bcac8 100644
--- a/target/linux/mediatek/filogic/base-files/etc/board.d/02_network
+++ b/target/linux/mediatek/filogic/base-files/etc/board.d/02_network
@@ -38,6 +38,9 @@ mediatek_setup_interfaces()
 	h3c,magic-nx30-pro)
 		ucidef_set_interfaces_lan_wan "lan1 lan2 lan3" eth1
 		;;
+	dlink,aquila-pro-ai-m30-a1)
+		ucidef_set_interfaces_lan_wan "lan1 lan2 lan3 lan4" eth1
+		;;
 	glinet,gl-mt3000)
 		ucidef_set_interfaces_lan_wan eth1 eth0
 		;;
diff --git a/target/linux/mediatek/filogic/base-files/etc/hotplug.d/ieee80211/11_fix_wifi_mac b/target/linux/mediatek/filogic/base-files/etc/hotplug.d/ieee80211/11_fix_wifi_mac
index 3441b41861..a7bbb62a95 100644
--- a/target/linux/mediatek/filogic/base-files/etc/hotplug.d/ieee80211/11_fix_wifi_mac
+++ b/target/linux/mediatek/filogic/base-files/etc/hotplug.d/ieee80211/11_fix_wifi_mac
@@ -70,6 +70,10 @@ case "$board" in
 		[ "$PHYNBR" = "0" ] && echo "$addr" > /sys${DEVPATH}/macaddress
 		[ "$PHYNBR" = "1" ] && macaddr_setbit_la $(macaddr_add $addr 1) > /sys${DEVPATH}/macaddress
 		;;
+	dlink,aquila-pro-ai-m30-a1)
+		addr=$(mtd_get_mac_binary "Odm" 0x81)
+		[ "$PHYNBR" = "1" ] && macaddr_add $addr 3 > /sys${DEVPATH}/macaddress
+		;;
 	glinet,gl-mt6000)
 		addr=$(mmc_get_mac_binary factory 0x04)
 		[ "$PHYNBR" = "0" ] && echo "$addr" > /sys${DEVPATH}/macaddress
diff --git a/target/linux/mediatek/filogic/base-files/etc/init.d/bootcount b/target/linux/mediatek/filogic/base-files/etc/init.d/bootcount
index c52d004c63..e186589f28 100644
--- a/target/linux/mediatek/filogic/base-files/etc/init.d/bootcount
+++ b/target/linux/mediatek/filogic/base-files/etc/init.d/bootcount
@@ -5,6 +5,13 @@ START=99
 
 boot() {
 	case $(board_name) in
+	dlink,aquila-pro-ai-m30-a1)
+		if grep -q bootpart=ubi0 /proc/cmdline; then
+			fw_setenv bootpart 0
+		else
+			fw_setenv bootpart 1
+		fi
+		;;
 	zyxel,ex5700-telenor)
 		fw_setenv uboot_bootcount 0
 		;;
diff --git a/target/linux/mediatek/image/filogic.mk b/target/linux/mediatek/image/filogic.mk
index 5598a70aca..84ac246d70 100644
--- a/target/linux/mediatek/image/filogic.mk
+++ b/target/linux/mediatek/image/filogic.mk
@@ -336,6 +336,21 @@ define Device/cudy_wr3000-v1
 endef
 TARGET_DEVICES += cudy_wr3000-v1
 
+define Device/dlink_aquila-pro-ai-m30-a1
+  DEVICE_VENDOR := D-Link
+  DEVICE_MODEL := AQUILA PRO AI M30
+  DEVICE_VARIANT := A1
+  DEVICE_DTS := mt7981b-dlink-aquila-pro-ai-m30-a1
+  DEVICE_DTS_DIR := ../dts
+  DEVICE_PACKAGES := kmod-leds-gca230718 kmod-mt7981-firmware mt7981-wo-firmware
+  KERNEL_IN_UBI := 1
+  IMAGES += recovery.bin
+  IMAGE_SIZE := 51200k
+  IMAGE/sysupgrade.bin := sysupgrade-tar | append-metadata
+  IMAGE/recovery.bin := sysupgrade-tar | pad-to $$(IMAGE_SIZE) | dlink-ai-recovery-header DLK6E6110001 \x6A\x28\xEE\x0B \x00\x00\x2C\x00 \x00\x00\x20\x03 \x61\x6E
+endef
+TARGET_DEVICES += dlink_aquila-pro-ai-m30-a1
+
 define Device/glinet_gl-mt3000
   DEVICE_VENDOR := GL.iNet
   DEVICE_MODEL := GL-MT3000
-- 
2.34.1

